{"/home/travis/build/npmtest/node-npmtest-ddp/test.js":"/* istanbul instrument in package npmtest_ddp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ddp/lib.npmtest_ddp.js":"/* istanbul instrument in package npmtest_ddp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_ddp = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_ddp = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-ddp/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-ddp && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_ddp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_ddp\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_ddp.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_ddp.rollup.js'] =\n            local.assetsDict['/assets.npmtest_ddp.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_ddp.__dirname +\n                    '/lib.npmtest_ddp.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ddp/node_modules/ddp/lib/ddp-client.js":"\"use strict\";\n\nvar util = require(\"util\");\nvar events = require(\"events\");\nvar WebSocket = require(\"faye-websocket\");\nvar EJSON = require(\"ddp-ejson\");\nvar request = require('request');\nvar pathJoin = require('path').join;\nvar _ = require(\"ddp-underscore-patched\");\n\nvar DDPClient = function(opts) {\n  var self = this;\n\n  opts = opts || {};\n\n  // backwards compatibility\n  if (\"use_ssl\" in opts)              { opts.ssl = opts.use_ssl; }\n  if (\"auto_reconnect\" in opts)       { opts.autoReconnect = opts.auto_reconnect; }\n  if (\"auto_reconnect_timer\" in opts) { opts.autoReconnectTimer = opts.auto_reconnect_timer; }\n  if (\"maintain_collections\" in opts) { opts.maintainCollections = opts.maintain_collections; }\n  if (\"ddp_version\" in opts)          { opts.ddpVersion = opts.ddp_version; }\n\n  // default arguments\n  self.host = opts.host || \"localhost\";\n  self.port = opts.port || 3000;\n  self.path = opts.path;\n  self.ssl  = opts.ssl  || self.port === 443;\n  self.tlsOpts = opts.tlsOpts || {};\n  self.useSockJs = opts.useSockJs || false;\n  self.autoReconnect = (\"autoReconnect\" in opts) ? opts.autoReconnect : true;\n  self.autoReconnectTimer = (\"autoReconnectTimer\" in opts) ? opts.autoReconnectTimer : 500;\n  self.maintainCollections = (\"maintainCollections\" in opts) ? opts.maintainCollections : true;\n  self.url  = opts.url;\n  // support multiple ddp versions\n  self.ddpVersion = (\"ddpVersion\" in opts) ? opts.ddpVersion : \"1\";\n  self.supportedDdpVersions = [\"1\", \"pre2\", \"pre1\"];\n\n  // Expose EJSON object, so client can use EJSON.addType(...)\n  self.EJSON = EJSON;\n\n  // very very simple collections (name -> [{id -> document}])\n  if (self.maintainCollections) {\n    self.collections = {};\n  }\n\n  // internal stuff to track callbacks\n  self._isConnecting = false;\n  self._isReconnecting = false;\n  self._nextId = 0;\n  self._callbacks = {};\n  self._updatedCallbacks = {};\n  self._pendingMethods = {};\n  self._observers = {};\n};\n\n\nDDPClient.ERRORS = {\n  DISCONNECTED: new Error(\"DDPClient: Disconnected from DDP server\")\n};\n\n\n/**\n * Inherits from EventEmitter\n */\nutil.inherits(DDPClient, events.EventEmitter);\n\n\nDDPClient.prototype._prepareHandlers = function() {\n  var self = this;\n\n  self.socket.on(\"open\", function() {\n    // just go ahead and open the connection on connect\n    self._send({\n      msg : \"connect\",\n      version : self.ddpVersion,\n      support : self.supportedDdpVersions\n    });\n  });\n\n  self.socket.on(\"error\", function(error) {\n    // error received before connection was established\n    if (self._isConnecting) {\n      self.emit(\"failed\", error.message);\n    }\n\n    self.emit(\"socket-error\", error);\n  });\n\n  self.socket.on(\"close\", function(event) {\n    self.emit(\"socket-close\", event.code, event.reason);\n    self._endPendingMethodCalls();\n    self._recoverNetworkError();\n  });\n\n  self.socket.on(\"message\", function(event) {\n    self._message(event.data);\n    self.emit(\"message\", event.data);\n  });\n};\n\nDDPClient.prototype._clearReconnectTimeout = function() {\n  var self = this;\n  if (self.reconnectTimeout) {\n    clearTimeout(self.reconnectTimeout);\n    self.reconnectTimeout = null;\n  }\n};\n\nDDPClient.prototype._recoverNetworkError = function() {\n  var self = this;\n  if (self.autoReconnect && ! self._connectionFailed && ! self._isClosing) {\n    self._clearReconnectTimeout();\n    self.reconnectTimeout = setTimeout(function() { self.connect(); }, self.autoReconnectTimer);\n    self._isReconnecting = true;\n  }\n};\n\n///////////////////////////////////////////////////////////////////////////\n// RAW, low level functions\nDDPClient.prototype._send = function(data) {\n  this.socket.send(\n    EJSON.stringify(data)\n  );\n};\n\n// handle a message from the server\nDDPClient.prototype._message = function(data) {\n  var self = this;\n\n  data = EJSON.parse(data);\n\n  // TODO: 'addedBefore' -- not yet implemented in Meteor\n  // TODO: 'movedBefore' -- not yet implemented in Meteor\n\n  if (!data.msg) {\n    return;\n\n  } else if (data.msg === \"failed\") {\n    if (self.supportedDdpVersions.indexOf(data.version) !== -1) {\n      this.ddpVersion = data.version;\n      self.connect();\n    } else {\n      self.autoReconnect = false;\n      self.emit(\"failed\", \"Cannot negotiate DDP version\");\n    }\n\n  } else if (data.msg === \"connected\") {\n    self.session = data.session;\n    self.emit(\"connected\");\n\n  // method result\n  } else if (data.msg === \"result\") {\n    var cb = self._callbacks[data.id];\n\n    if (cb) {\n      cb(data.error, data.result);\n      delete self._callbacks[data.id];\n    }\n\n  // method updated\n  } else if (data.msg === \"updated\") {\n\n    _.each(data.methods, function (method) {\n      var cb = self._updatedCallbacks[method];\n      if (cb) {\n        cb();\n        delete self._updatedCallbacks[method];\n      }\n    });\n\n  // missing subscription\n  } else if (data.msg === \"nosub\") {\n    var cb = self._callbacks[data.id];\n\n    if (cb) {\n      cb(data.error);\n      delete self._callbacks[data.id];\n    }\n\n  // add document to collection\n  } else if (data.msg === \"added\") {\n    if (self.maintainCollections && data.collection) {\n      var name = data.collection, id = data.id;\n\n      if (! self.collections[name])     { self.collections[name] = {}; }\n      if (! self.collections[name][id]) { self.collections[name][id] = {}; }\n\n      self.collections[name][id]._id = id;\n\n      if (data.fields) {\n        _.each(data.fields, function(value, key) {\n          self.collections[name][id][key] = value;\n        });\n      }\n\n      if (self._observers[name]) {\n        _.each(self._observers[name], function(observer) {\n          observer.added(id);\n        });\n      }\n    }\n\n  // remove document from collection\n  } else if (data.msg === \"removed\") {\n    if (self.maintainCollections && data.collection) {\n      var name = data.collection, id = data.id;\n\n      if (! self.collections[name][id]) {\n        return;\n      }\n\n      var oldValue = self.collections[name][id];\n\n      delete self.collections[name][id];\n\n      if (self._observers[name]) {\n        _.each(self._observers[name], function(observer) {\n          observer.removed(id, oldValue);\n        });\n      }\n    }\n\n  // change document in collection\n  } else if (data.msg === \"changed\") {\n    if (self.maintainCollections && data.collection) {\n      var name = data.collection, id = data.id;\n\n      if (! self.collections[name])     { return; }\n      if (! self.collections[name][id]) { return; }\n\n      var oldFields     = {},\n          clearedFields = data.cleared || [],\n          newFields = {};\n\n      if (data.fields) {\n        _.each(data.fields, function(value, key) {\n            oldFields[key] = self.collections[name][id][key];\n            newFields[key] = value;\n            self.collections[name][id][key] = value;\n        });\n      }\n\n      if (data.cleared) {\n        _.each(data.cleared, function(value) {\n            delete self.collections[name][id][value];\n        });\n      }\n\n      if (self._observers[name]) {\n        _.each(self._observers[name], function(observer) {\n          observer.changed(id, oldFields, clearedFields, newFields);\n        });\n      }\n    }\n\n  // subscriptions ready\n  } else if (data.msg === \"ready\") {\n    _.each(data.subs, function(id) {\n      var cb = self._callbacks[id];\n      if (cb) {\n        cb();\n        delete self._callbacks[id];\n      }\n    });\n\n  // minimal heartbeat response for ddp pre2\n  } else if (data.msg === \"ping\") {\n    self._send(\n      _.has(data, \"id\") ? { msg : \"pong\", id : data.id } : { msg : \"pong\" }\n    );\n  }\n};\n\n\nDDPClient.prototype._getNextId = function() {\n  return (this._nextId += 1).toString();\n};\n\n\nDDPClient.prototype._addObserver = function(observer) {\n  if (! this._observers[observer.name]) {\n    this._observers[observer.name] = {};\n  }\n  this._observers[observer.name][observer._id] = observer;\n};\n\n\nDDPClient.prototype._removeObserver = function(observer) {\n  if (! this._observers[observer.name]) { return; }\n\n  delete this._observers[observer.name][observer._id];\n};\n\n//////////////////////////////////////////////////////////////////////////\n// USER functions -- use these to control the client\n\n/* open the connection to the server\n *\n *  connected(): Called when the 'connected' message is received\n *               If autoReconnect is true (default), the callback will be\n *               called each time the connection is opened.\n */\nDDPClient.prototype.connect = function(connected) {\n  var self = this;\n  self._isConnecting = true;\n  self._connectionFailed = false;\n  self._isClosing = false;\n\n  if (connected) {\n    self.addListener(\"connected\", function() {\n      self._clearReconnectTimeout();\n\n      connected(undefined, self._isReconnecting);\n      self._isConnecting = false;\n      self._isReconnecting = false;\n    });\n    self.addListener(\"failed\", function(error) {\n      self._isConnecting = false;\n      self._connectionFailed = true;\n      connected(error, self._isReconnecting);\n    });\n  }\n\n  if (self.useSockJs) {\n    self._makeSockJSConnection();\n  } else {\n    var url = self._buildWsUrl();\n    self._makeWebSocketConnection(url);\n  }\n};\n\nDDPClient.prototype._endPendingMethodCalls = function() {\n  var self = this;\n  var ids = _.keys(self._pendingMethods);\n  self._pendingMethods = {};\n\n  ids.forEach(function (id) {\n    if (self._callbacks[id]) {\n      self._callbacks[id](DDPClient.ERRORS.DISCONNECTED);\n      delete self._callbacks[id];\n    }\n\n    if (self._updatedCallbacks[id]) {\n      self._updatedCallbacks[id]();\n      delete self._updatedCallbacks[id];\n    }\n  });\n};\n\nDDPClient.prototype._makeSockJSConnection = function() {\n  var self = this;\n\n  // do the info hit\n  var protocol = self.ssl ? \"https://\" : \"http://\";\n  var randomValue = \"\" + Math.ceil(Math.random() * 9999999);\n  var path = pathJoin(\"/\", self.path || \"\", \"sockjs/info\");\n  var url = protocol + self.host + \":\" + self.port + path;\n\n  var requestOpts = { 'url': url, 'agentOptions': self.tlsOpts };\n\n  request.get(requestOpts, function(err, res, body) {\n    if (err) {\n      self._recoverNetworkError();\n    } else if (body) {\n      var info;\n      try {\n        info = JSON.parse(body);\n      } catch (e) {\n        console.error(e);\n      }\n      if (!info || !info.base_url) {\n        // no base_url, then use pure WS handling\n        var url = self._buildWsUrl();\n        self._makeWebSocketConnection(url);\n      } else if (info.base_url.indexOf(\"http\") === 0) {\n        // base url for a different host\n        var url = info.base_url + \"/websocket\";\n        url = url.replace(/^http/, \"ws\");\n        self._makeWebSocketConnection(url);\n      } else {\n        // base url for the same host\n        var path = info.base_url + \"/websocket\";\n        var url = self._buildWsUrl(path);\n        self._makeWebSocketConnection(url);\n      }\n    } else {\n      // no body. weird. use pure WS handling\n      var url = self._buildWsUrl();\n      self._makeWebSocketConnection(url);\n    }\n  });\n};\n\nDDPClient.prototype._buildWsUrl = function(path) {\n  var self = this;\n  var url;\n  path = path || self.path || \"websocket\";\n  var protocol = self.ssl ? \"wss://\" : \"ws://\";\n  if (self.url && !self.useSockJs) {\n    url = self.url;\n  } else {\n    url = protocol + self.host + \":\" + self.port;\n    url += (path.indexOf(\"/\") === 0)? path : \"/\" + path;\n  }\n  return url;\n};\n\nDDPClient.prototype._makeWebSocketConnection = function(url) {\n  var self = this;\n  self.socket = new WebSocket.Client(url, null, self.tlsOpts);\n  self._prepareHandlers();\n};\n\nDDPClient.prototype.close = function() {\n  var self = this;\n  self._isClosing = true;\n  self.socket.close();\n  self.removeAllListeners(\"connected\");\n  self.removeAllListeners(\"failed\");\n};\n\n\n// call a method on the server,\n//\n// callback = function(err, result)\nDDPClient.prototype.call = function(name, params, callback, updatedCallback) {\n  var self = this;\n  var id = self._getNextId();\n\n  self._callbacks[id] = function () {\n    delete self._pendingMethods[id];\n\n    if (callback) {\n      callback.apply(this, arguments);\n    }\n  };\n\n  self._updatedCallbacks[id] = function () {\n    delete self._pendingMethods[id];\n\n    if (updatedCallback) {\n      updatedCallback.apply(this, arguments);\n    }\n  };\n\n  self._pendingMethods[id] = true;\n\n  self._send({\n    msg    : \"method\",\n    id     : id,\n    method : name,\n    params : params\n  });\n};\n\n\nDDPClient.prototype.callWithRandomSeed = function(name, params, randomSeed, callback, updatedCallback) {\n  var self = this;\n  var id = self._getNextId();\n\n  if (callback) {\n    self._callbacks[id] = callback;\n  }\n\n  if (updatedCallback) {\n    self._updatedCallbacks[id] = updatedCallback;\n  }\n\n  self._send({\n    msg        : \"method\",\n    id         : id,\n    method     : name,\n    randomSeed : randomSeed,\n    params     : params\n  });\n};\n\n// open a subscription on the server, callback should handle on ready and nosub\nDDPClient.prototype.subscribe = function(name, params, callback) {\n  var self = this;\n  var id = self._getNextId();\n\n  if (callback) {\n    self._callbacks[id] = callback;\n  }\n\n  self._send({\n    msg    : \"sub\",\n    id     : id,\n    name   : name,\n    params : params\n  });\n\n  return id;\n};\n\nDDPClient.prototype.unsubscribe = function(id) {\n  var self = this;\n\n  self._send({\n    msg : \"unsub\",\n    id  : id\n  });\n};\n\n/**\n * Adds an observer to a collection and returns the observer.\n * Observation can be stopped by calling the stop() method on the observer.\n * Functions for added, changed and removed can be added to the observer\n * afterward.\n */\nDDPClient.prototype.observe = function(name, added, changed, removed) {\n  var self = this;\n  var observer = {};\n  var id = self._getNextId();\n\n  // name, _id are immutable\n  Object.defineProperty(observer, \"name\", {\n    get: function() { return name; },\n    enumerable: true\n  });\n\n  Object.defineProperty(observer, \"_id\", { get: function() { return id; }});\n\n  observer.added   = added   || function(){};\n  observer.changed = changed || function(){};\n  observer.removed = removed || function(){};\n\n  observer.stop = function() {\n    self._removeObserver(observer);\n  };\n\n  self._addObserver(observer);\n\n  return observer;\n};\n\nmodule.exports = DDPClient;\n","/home/travis/build/npmtest/node-npmtest-ddp/node_modules/ddp-ejson/ejson.js":"var EJSON = exports; // Global!\nvar _ = require('ddp-underscore-patched');\n\nEJSON.ObjectID = require('./objectid.js');\n\nvar customTypes = {\n  oid: function (str) { return new EJSON.ObjectID(str); }\n};\n\n// Base 64 encoding\n\nvar BASE_64_CHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nvar BASE_64_VALS = {};\n\nfor (var i = 0; i < BASE_64_CHARS.length; i++) {\n  BASE_64_VALS[BASE_64_CHARS.charAt(i)] = i;\n};\n\nEJSON._base64Encode = function (array) {\n  var answer = [];\n  var a = null;\n  var b = null;\n  var c = null;\n  var d = null;\n  for (var i = 0; i < array.length; i++) {\n    switch (i % 3) {\n    case 0:\n      a = (array[i] >> 2) & 0x3F;\n      b = (array[i] & 0x03) << 4;\n      break;\n    case 1:\n      b = b | (array[i] >> 4) & 0xF;\n      c = (array[i] & 0xF) << 2;\n      break;\n    case 2:\n      c = c | (array[i] >> 6) & 0x03;\n      d = array[i] & 0x3F;\n      answer.push(getChar(a));\n      answer.push(getChar(b));\n      answer.push(getChar(c));\n      answer.push(getChar(d));\n      a = null;\n      b = null;\n      c = null;\n      d = null;\n      break;\n    }\n  }\n  if (a != null) {\n    answer.push(getChar(a));\n    answer.push(getChar(b));\n    if (c == null)\n      answer.push('=');\n    else\n      answer.push(getChar(c));\n    if (d == null)\n      answer.push('=');\n  }\n  return answer.join(\"\");\n};\n\nvar getChar = function (val) {\n  return BASE_64_CHARS.charAt(val);\n};\n\nvar getVal = function (ch) {\n  if (ch === '=') {\n    return -1;\n  }\n  return BASE_64_VALS[ch];\n};\n\nEJSON.newBinary = function (len) {\n  if (typeof Uint8Array === 'undefined' || typeof ArrayBuffer === 'undefined') {\n    var ret = [];\n    for (var i = 0; i < len; i++) {\n      ret.push(0);\n    }\n    ret.$Uint8ArrayPolyfill = true;\n    return ret;\n  }\n  return new Uint8Array(new ArrayBuffer(len));\n};\n\nEJSON._base64Decode = function (str) {\n  var len = Math.floor((str.length*3)/4);\n  if (str.charAt(str.length - 1) == '=') {\n    len--;\n    if (str.charAt(str.length - 2) == '=')\n      len--;\n  }\n  var arr = EJSON.newBinary(len);\n\n  var one = null;\n  var two = null;\n  var three = null;\n\n  var j = 0;\n\n  for (var i = 0; i < str.length; i++) {\n    var c = str.charAt(i);\n    var v = getVal(c);\n    switch (i % 4) {\n    case 0:\n      if (v < 0)\n        throw new Error('invalid base64 string');\n      one = v << 2;\n      break;\n    case 1:\n      if (v < 0)\n        throw new Error('invalid base64 string');\n      one = one | (v >> 4);\n      arr[j++] = one;\n      two = (v & 0x0F) << 4;\n      break;\n    case 2:\n      if (v >= 0) {\n        two = two | (v >> 2);\n        arr[j++] = two;\n        three = (v & 0x03) << 6;\n      }\n      break;\n    case 3:\n      if (v >= 0) {\n        arr[j++] = three | v;\n      }\n      break;\n    }\n  }\n  return arr;\n};\n\n\n// Add a custom type, using a method of your choice to get to and\n// from a basic JSON-able representation.  The factory argument\n// is a function of JSON-able --> your object\n// The type you add must have:\n// - A toJSONValue() method, so that Meteor can serialize it\n// - a typeName() method, to show how to look it up in our type table.\n// It is okay if these methods are monkey-patched on.\n// EJSON.clone will use toJSONValue and the given factory to produce\n// a clone, but you may specify a method clone() that will be\n// used instead.\n// Similarly, EJSON.equals will use toJSONValue to make comparisons,\n// but you may provide a method equals() instead.\n//\nEJSON.addType = function (name, factory) {\n  if (_.has(customTypes, name))\n    throw new Error(\"Type \" + name + \" already present\");\n  customTypes[name] = factory;\n};\n\nvar isInfOrNan = function (obj) {\n  return _.isNaN(obj) || obj === Infinity || obj === -Infinity;\n};\n\nvar builtinConverters = [\n  { // Date\n    matchJSONValue: function (obj) {\n      return _.has(obj, '$date') && _.size(obj) === 1;\n    },\n    matchObject: function (obj) {\n      return obj instanceof Date;\n    },\n    toJSONValue: function (obj) {\n      return {$date: obj.getTime()};\n    },\n    fromJSONValue: function (obj) {\n      return new Date(obj.$date);\n    }\n  },\n  { // NaN, Inf, -Inf. (These are the only objects with typeof !== 'object'\n    // which we match.)\n    matchJSONValue: function (obj) {\n      return _.has(obj, '$InfNaN') && _.size(obj) === 1;\n    },\n    matchObject: isInfOrNan,\n    toJSONValue: function (obj) {\n      var sign;\n      if (_.isNaN(obj))\n        sign = 0;\n      else if (obj === Infinity)\n        sign = 1;\n      else\n        sign = -1;\n      return {$InfNaN: sign};\n    },\n    fromJSONValue: function (obj) {\n      return obj.$InfNaN/0;\n    }\n  },\n  { // Binary\n    matchJSONValue: function (obj) {\n      return _.has(obj, '$binary') && _.size(obj) === 1;\n    },\n    matchObject: function (obj) {\n      return typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array\n        || (obj && _.has(obj, '$Uint8ArrayPolyfill'));\n    },\n    toJSONValue: function (obj) {\n      return {$binary: EJSON._base64Encode(obj)};\n    },\n    fromJSONValue: function (obj) {\n      return EJSON._base64Decode(obj.$binary);\n    }\n  },\n  { // Escaping one level\n    matchJSONValue: function (obj) {\n      return _.has(obj, '$escape') && _.size(obj) === 1;\n    },\n    matchObject: function (obj) {\n      if (_.isEmpty(obj) || _.size(obj) > 2) {\n        return false;\n      }\n      return _.any(builtinConverters, function (converter) {\n        return converter.matchJSONValue(obj);\n      });\n    },\n    toJSONValue: function (obj) {\n      var newObj = {};\n      _.each(obj, function (value, key) {\n        newObj[key] = EJSON.toJSONValue(value);\n      });\n      return {$escape: newObj};\n    },\n    fromJSONValue: function (obj) {\n      var newObj = {};\n      _.each(obj.$escape, function (value, key) {\n        newObj[key] = EJSON.fromJSONValue(value);\n      });\n      return newObj;\n    }\n  },\n  { // Custom\n    matchJSONValue: function (obj) {\n      return _.has(obj, '$type') && _.has(obj, '$value') && _.size(obj) === 2;\n    },\n    matchObject: function (obj) {\n      return EJSON._isCustomType(obj);\n    },\n    toJSONValue: function (obj) {\n      return {$type: obj.typeName(), $value: obj.toJSONValue()};\n    },\n    fromJSONValue: function (obj) {\n      var typeName = obj.$type;\n      if (!_.has(customTypes, typeName))\n        throw new Error(\"Custom EJSON type \" + typeName + \" is not defined\");\n      var converter = customTypes[typeName];\n      return converter(obj.$value);\n    }\n  }\n];\n\nEJSON._isCustomType = function (obj) {\n  return obj &&\n    typeof obj.toJSONValue === 'function' &&\n    typeof obj.typeName === 'function' &&\n    _.has(customTypes, obj.typeName());\n};\n\n\n// for both arrays and objects, in-place modification.\nvar adjustTypesToJSONValue =\nEJSON._adjustTypesToJSONValue = function (obj) {\n  // Is it an atom that we need to adjust?\n  if (obj === null)\n    return null;\n  var maybeChanged = toJSONValueHelper(obj);\n  if (maybeChanged !== undefined)\n    return maybeChanged;\n\n  // Other atoms are unchanged.\n  if (typeof obj !== 'object')\n    return obj;\n\n  // Iterate over array or object structure.\n  _.each(obj, function (value, key) {\n    if (typeof value !== 'object' && value !== undefined &&\n        !isInfOrNan(value))\n      return; // continue\n\n    var changed = toJSONValueHelper(value);\n    if (changed) {\n      obj[key] = changed;\n      return; // on to the next key\n    }\n    // if we get here, value is an object but not adjustable\n    // at this level.  recurse.\n    adjustTypesToJSONValue(value);\n  });\n  return obj;\n};\n\n// Either return the JSON-compatible version of the argument, or undefined (if\n// the item isn't itself replaceable, but maybe some fields in it are)\nvar toJSONValueHelper = function (item) {\n  for (var i = 0; i < builtinConverters.length; i++) {\n    var converter = builtinConverters[i];\n    if (converter.matchObject(item)) {\n      return converter.toJSONValue(item);\n    }\n  }\n  return undefined;\n};\n\nEJSON.toJSONValue = function (item) {\n  var changed = toJSONValueHelper(item);\n  if (changed !== undefined)\n    return changed;\n  if (typeof item === 'object') {\n    item = EJSON.clone(item);\n    adjustTypesToJSONValue(item);\n  }\n  return item;\n};\n\n// for both arrays and objects. Tries its best to just\n// use the object you hand it, but may return something\n// different if the object you hand it itself needs changing.\n//\nvar adjustTypesFromJSONValue =\nEJSON._adjustTypesFromJSONValue = function (obj) {\n  if (obj === null)\n    return null;\n  var maybeChanged = fromJSONValueHelper(obj);\n  if (maybeChanged !== obj)\n    return maybeChanged;\n\n  // Other atoms are unchanged.\n  if (typeof obj !== 'object')\n    return obj;\n\n  _.each(obj, function (value, key) {\n    if (typeof value === 'object') {\n      var changed = fromJSONValueHelper(value);\n      if (value !== changed) {\n        obj[key] = changed;\n        return;\n      }\n      // if we get here, value is an object but not adjustable\n      // at this level.  recurse.\n      adjustTypesFromJSONValue(value);\n    }\n  });\n  return obj;\n};\n\n// Either return the argument changed to have the non-json\n// rep of itself (the Object version) or the argument itself.\n\n// DOES NOT RECURSE.  For actually getting the fully-changed value, use\n// EJSON.fromJSONValue\nvar fromJSONValueHelper = function (value) {\n  if (typeof value === 'object' && value !== null) {\n    if (_.size(value) <= 2\n        && _.all(value, function (v, k) {\n          return typeof k === 'string' && k.substr(0, 1) === '$';\n        })) {\n      for (var i = 0; i < builtinConverters.length; i++) {\n        var converter = builtinConverters[i];\n        if (converter.matchJSONValue(value)) {\n          return converter.fromJSONValue(value);\n        }\n      }\n    }\n  }\n  return value;\n};\n\nEJSON.fromJSONValue = function (item) {\n  var changed = fromJSONValueHelper(item);\n  if (changed === item && typeof item === 'object') {\n    item = EJSON.clone(item);\n    adjustTypesFromJSONValue(item);\n    return item;\n  } else {\n    return changed;\n  }\n};\n\nEJSON.stringify = function (item, options) {\n  var json = EJSON.toJSONValue(item);\n  if (options && (options.canonical || options.indent)) {\n    return EJSON._canonicalStringify(json, options);\n  } else {\n    return JSON.stringify(json);\n  }\n};\n\nEJSON.parse = function (item) {\n  if (typeof item !== 'string')\n    throw new Error(\"EJSON.parse argument should be a string\");\n  return EJSON.fromJSONValue(JSON.parse(item));\n};\n\nEJSON.isBinary = function (obj) {\n  return !!((typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array) ||\n    (obj && obj.$Uint8ArrayPolyfill));\n};\n\nEJSON.equals = function (a, b, options) {\n  var i;\n  var keyOrderSensitive = !!(options && options.keyOrderSensitive);\n  if (a === b)\n    return true;\n  if (_.isNaN(a) && _.isNaN(b))\n    return true; // This differs from the IEEE spec for NaN equality, b/c we don't want\n                 // anything ever with a NaN to be poisoned from becoming equal to anything.\n  if (!a || !b) // if either one is falsy, they'd have to be === to be equal\n    return false;\n  if (!(typeof a === 'object' && typeof b === 'object'))\n    return false;\n  if (a instanceof Date && b instanceof Date)\n    return a.valueOf() === b.valueOf();\n  if (EJSON.isBinary(a) && EJSON.isBinary(b)) {\n    if (a.length !== b.length)\n      return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i])\n        return false;\n    }\n    return true;\n  }\n  if (typeof (a.equals) === 'function')\n    return a.equals(b, options);\n  if (typeof (b.equals) === 'function')\n    return b.equals(a, options);\n  if (a instanceof Array) {\n    if (!(b instanceof Array))\n      return false;\n    if (a.length !== b.length)\n      return false;\n    for (i = 0; i < a.length; i++) {\n      if (!EJSON.equals(a[i], b[i], options))\n        return false;\n    }\n    return true;\n  }\n  // fallback for custom types that don't implement their own equals\n  switch (EJSON._isCustomType(a) + EJSON._isCustomType(b)) {\n    case 1: return false;\n    case 2: return EJSON.equals(EJSON.toJSONValue(a), EJSON.toJSONValue(b));\n  }\n  // fall back to structural equality of objects\n  var ret;\n  if (keyOrderSensitive) {\n    var bKeys = [];\n    _.each(b, function (val, x) {\n        bKeys.push(x);\n    });\n    i = 0;\n    ret = _.all(a, function (val, x) {\n      if (i >= bKeys.length) {\n        return false;\n      }\n      if (x !== bKeys[i]) {\n        return false;\n      }\n      if (!EJSON.equals(val, b[bKeys[i]], options)) {\n        return false;\n      }\n      i++;\n      return true;\n    });\n    return ret && i === bKeys.length;\n  } else {\n    i = 0;\n    ret = _.all(a, function (val, key) {\n      if (!_.has(b, key)) {\n        return false;\n      }\n      if (!EJSON.equals(val, b[key], options)) {\n        return false;\n      }\n      i++;\n      return true;\n    });\n    return ret && _.size(b) === i;\n  }\n};\n\nEJSON.clone = function (v) {\n  var ret;\n  if (typeof v !== \"object\")\n    return v;\n  if (v === null)\n    return null; // null has typeof \"object\"\n  if (v instanceof Date)\n    return new Date(v.getTime());\n  // RegExps are not really EJSON elements (eg we don't define a serialization\n  // for them), but they're immutable anyway, so we can support them in clone.\n  if (v instanceof RegExp)\n    return v;\n  if (EJSON.isBinary(v)) {\n    ret = EJSON.newBinary(v.length);\n    for (var i = 0; i < v.length; i++) {\n      ret[i] = v[i];\n    }\n    return ret;\n  }\n  // XXX: Use something better than underscore's isArray\n  if (_.isArray(v) || _.isArguments(v)) {\n    // For some reason, _.map doesn't work in this context on Opera (weird test\n    // failures).\n    ret = [];\n    for (i = 0; i < v.length; i++)\n      ret[i] = EJSON.clone(v[i]);\n    return ret;\n  }\n  // handle general user-defined typed Objects if they have a clone method\n  if (typeof v.clone === 'function') {\n    return v.clone();\n  }\n  // handle other custom types\n  if (EJSON._isCustomType(v)) {\n    return EJSON.fromJSONValue(EJSON.clone(EJSON.toJSONValue(v)), true);\n  }\n  // handle other objects\n  ret = {};\n  _.each(v, function (value, key) {\n    ret[key] = EJSON.clone(value);\n  });\n  return ret;\n};\n\n","/home/travis/build/npmtest/node-npmtest-ddp/node_modules/ddp-underscore-patched/underscore.js":"//     Underscore.js 1.5.2\n//     http://underscorejs.org\n//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n\n// Baseline setup\n// --------------\n\n// Establish the root object, `window` in the browser, or `exports` on the server.\nvar root = this;\n\n// Save the previous value of the `_` variable.\nvar previousUnderscore = root._;\n\n// Establish the object that gets returned to break out of a loop iteration.\nvar breaker = {};\n\n// Save bytes in the minified (but not gzipped) version:\nvar ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n// Create quick reference variables for speed access to core prototypes.\nvar\n  push             = ArrayProto.push,\n  slice            = ArrayProto.slice,\n  concat           = ArrayProto.concat,\n  toString         = ObjProto.toString,\n  hasOwnProperty   = ObjProto.hasOwnProperty;\n\n// All **ECMAScript 5** native function implementations that we hope to use\n// are declared here.\nvar\n  nativeForEach      = ArrayProto.forEach,\n  nativeMap          = ArrayProto.map,\n  nativeReduce       = ArrayProto.reduce,\n  nativeReduceRight  = ArrayProto.reduceRight,\n  nativeFilter       = ArrayProto.filter,\n  nativeEvery        = ArrayProto.every,\n  nativeSome         = ArrayProto.some,\n  nativeIndexOf      = ArrayProto.indexOf,\n  nativeLastIndexOf  = ArrayProto.lastIndexOf,\n  nativeIsArray      = Array.isArray,\n  nativeKeys         = Object.keys,\n  nativeBind         = FuncProto.bind;\n\n// Create a safe reference to the Underscore object for use below.\nvar _ = function(obj) {\n  if (obj instanceof _) return obj;\n  if (!(this instanceof _)) return new _(obj);\n  this._wrapped = obj;\n};\n\n// Export the Underscore object for **Node.js**, with\n// backwards-compatibility for the old `require()` API. If we're in\n// the browser, add `_` as a global object via a string identifier,\n// for Closure Compiler \"advanced\" mode.\nif (typeof exports !== 'undefined') {\n  if (typeof module !== 'undefined' && module.exports) {\n    exports = module.exports = _;\n  }\n  exports._ = _;\n} else {\n  root._ = _;\n}\n\n// Current version.\n_.VERSION = '1.5.2';\n\n// Collection Functions\n// --------------------\n\n// METEOR CHANGE: Define _isArguments instead of depending on\n// _.isArguments which is defined using each. In looksLikeArray\n// (which each depends on), we then use _isArguments instead of\n// _.isArguments.\nvar _isArguments = function (obj) {\n  return toString.call(obj) === '[object Arguments]';\n};\n// Define a fallback version of the method in browsers (ahem, IE), where\n// there isn't any inspectable \"Arguments\" type.\nif (!_isArguments(arguments)) {\n  _isArguments = function (obj) {\n    return !!(obj && hasOwnProperty.call(obj, 'callee') && typeof obj.callee === 'function');\n  };\n}\n\n// METEOR CHANGE: _.each({length: 5}) should be treated like an object, not an\n// array. This looksLikeArray function is introduced by Meteor, and replaces\n// all instances of `obj.length === +obj.length`.\n// https://github.com/meteor/meteor/issues/594\n// https://github.com/jashkenas/underscore/issues/770\nvar looksLikeArray = function (obj) {\n  return (obj.length === +obj.length\n          // _.isArguments not yet necessarily defined here\n          && (_isArguments(obj) || obj.constructor !== Object));\n};\n\n// The cornerstone, an `each` implementation, aka `forEach`.\n// Handles objects with the built-in `forEach`, arrays, and raw objects.\n// Delegates to **ECMAScript 5**'s native `forEach` if available.\nvar each = _.each = _.forEach = function(obj, iterator, context) {\n  if (obj == null) return;\n  if (nativeForEach && obj.forEach === nativeForEach) {\n    obj.forEach(iterator, context);\n  } else if (looksLikeArray(obj)) {\n    for (var i = 0, length = obj.length; i < length; i++) {\n      if (iterator.call(context, obj[i], i, obj) === breaker) return;\n    }\n  } else {\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;\n    }\n  }\n};\n\n// Return the results of applying the iterator to each element.\n// Delegates to **ECMAScript 5**'s native `map` if available.\n_.map = _.collect = function(obj, iterator, context) {\n  var results = [];\n  if (obj == null) return results;\n  if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n  each(obj, function(value, index, list) {\n    results.push(iterator.call(context, value, index, list));\n  });\n  return results;\n};\n\nvar reduceError = 'Reduce of empty array with no initial value';\n\n// **Reduce** builds up a single result from a list of values, aka `inject`,\n// or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n_.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n  var initial = arguments.length > 2;\n  if (obj == null) obj = [];\n  if (nativeReduce && obj.reduce === nativeReduce) {\n    if (context) iterator = _.bind(iterator, context);\n    return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n  }\n  each(obj, function(value, index, list) {\n    if (!initial) {\n      memo = value;\n      initial = true;\n    } else {\n      memo = iterator.call(context, memo, value, index, list);\n    }\n  });\n  if (!initial) throw new TypeError(reduceError);\n  return memo;\n};\n\n// The right-associative version of reduce, also known as `foldr`.\n// Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n_.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n  var initial = arguments.length > 2;\n  if (obj == null) obj = [];\n  if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n    if (context) iterator = _.bind(iterator, context);\n    return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n  }\n  var length = obj.length;\n  if (!looksLikeArray(obj)) {\n    var keys = _.keys(obj);\n    length = keys.length;\n  }\n  each(obj, function(value, index, list) {\n    index = keys ? keys[--length] : --length;\n    if (!initial) {\n      memo = obj[index];\n      initial = true;\n    } else {\n      memo = iterator.call(context, memo, obj[index], index, list);\n    }\n  });\n  if (!initial) throw new TypeError(reduceError);\n  return memo;\n};\n\n// Return the first value which passes a truth test. Aliased as `detect`.\n_.find = _.detect = function(obj, iterator, context) {\n  var result;\n  any(obj, function(value, index, list) {\n    if (iterator.call(context, value, index, list)) {\n      result = value;\n      return true;\n    }\n  });\n  return result;\n};\n\n// Return all the elements that pass a truth test.\n// Delegates to **ECMAScript 5**'s native `filter` if available.\n// Aliased as `select`.\n_.filter = _.select = function(obj, iterator, context) {\n  var results = [];\n  if (obj == null) return results;\n  if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n  each(obj, function(value, index, list) {\n    if (iterator.call(context, value, index, list)) results.push(value);\n  });\n  return results;\n};\n\n// Return all the elements for which a truth test fails.\n_.reject = function(obj, iterator, context) {\n  return _.filter(obj, function(value, index, list) {\n    return !iterator.call(context, value, index, list);\n  }, context);\n};\n\n// Determine whether all of the elements match a truth test.\n// Delegates to **ECMAScript 5**'s native `every` if available.\n// Aliased as `all`.\n_.every = _.all = function(obj, iterator, context) {\n  iterator || (iterator = _.identity);\n  var result = true;\n  if (obj == null) return result;\n  if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n  each(obj, function(value, index, list) {\n    if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n  });\n  return !!result;\n};\n\n// Determine if at least one element in the object matches a truth test.\n// Delegates to **ECMAScript 5**'s native `some` if available.\n// Aliased as `any`.\nvar any = _.some = _.any = function(obj, iterator, context) {\n  iterator || (iterator = _.identity);\n  var result = false;\n  if (obj == null) return result;\n  if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n  each(obj, function(value, index, list) {\n    if (result || (result = iterator.call(context, value, index, list))) return breaker;\n  });\n  return !!result;\n};\n\n// Determine if the array or object contains a given value (using `===`).\n// Aliased as `include`.\n_.contains = _.include = function(obj, target) {\n  if (obj == null) return false;\n  if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n  return any(obj, function(value) {\n    return value === target;\n  });\n};\n\n// Invoke a method (with arguments) on every item in a collection.\n_.invoke = function(obj, method) {\n  var args = slice.call(arguments, 2);\n  var isFunc = _.isFunction(method);\n  return _.map(obj, function(value) {\n    return (isFunc ? method : value[method]).apply(value, args);\n  });\n};\n\n// Convenience version of a common use case of `map`: fetching a property.\n_.pluck = function(obj, key) {\n  return _.map(obj, function(value){ return value[key]; });\n};\n\n// Convenience version of a common use case of `filter`: selecting only objects\n// containing specific `key:value` pairs.\n_.where = function(obj, attrs, first) {\n  if (_.isEmpty(attrs)) return first ? void 0 : [];\n  return _[first ? 'find' : 'filter'](obj, function(value) {\n    for (var key in attrs) {\n      if (attrs[key] !== value[key]) return false;\n    }\n    return true;\n  });\n};\n\n// Convenience version of a common use case of `find`: getting the first object\n// containing specific `key:value` pairs.\n_.findWhere = function(obj, attrs) {\n  return _.where(obj, attrs, true);\n};\n\n// Return the maximum element or (element-based computation).\n// Can't optimize arrays of integers longer than 65,535 elements.\n// See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)\n_.max = function(obj, iterator, context) {\n  if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n    return Math.max.apply(Math, obj);\n  }\n  if (!iterator && _.isEmpty(obj)) return -Infinity;\n  var result = {computed : -Infinity, value: -Infinity};\n  each(obj, function(value, index, list) {\n    var computed = iterator ? iterator.call(context, value, index, list) : value;\n    computed > result.computed && (result = {value : value, computed : computed});\n  });\n  return result.value;\n};\n\n// Return the minimum element (or element-based computation).\n_.min = function(obj, iterator, context) {\n  if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n    return Math.min.apply(Math, obj);\n  }\n  if (!iterator && _.isEmpty(obj)) return Infinity;\n  var result = {computed : Infinity, value: Infinity};\n  each(obj, function(value, index, list) {\n    var computed = iterator ? iterator.call(context, value, index, list) : value;\n    computed < result.computed && (result = {value : value, computed : computed});\n  });\n  return result.value;\n};\n\n// Shuffle an array, using the modern version of the \n// [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n_.shuffle = function(obj) {\n  var rand;\n  var index = 0;\n  var shuffled = [];\n  each(obj, function(value) {\n    rand = _.random(index++);\n    shuffled[index - 1] = shuffled[rand];\n    shuffled[rand] = value;\n  });\n  return shuffled;\n};\n\n// Sample **n** random values from an array.\n// If **n** is not specified, returns a single random element from the array.\n// The internal `guard` argument allows it to work with `map`.\n_.sample = function(obj, n, guard) {\n  if (arguments.length < 2 || guard) {\n    return obj[_.random(obj.length - 1)];\n  }\n  return _.shuffle(obj).slice(0, Math.max(0, n));\n};\n\n// An internal function to generate lookup iterators.\nvar lookupIterator = function(value) {\n  return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n};\n\n// Sort the object's values by a criterion produced by an iterator.\n_.sortBy = function(obj, value, context) {\n  var iterator = lookupIterator(value);\n  return _.pluck(_.map(obj, function(value, index, list) {\n    return {\n      value: value,\n      index: index,\n      criteria: iterator.call(context, value, index, list)\n    };\n  }).sort(function(left, right) {\n    var a = left.criteria;\n    var b = right.criteria;\n    if (a !== b) {\n      if (a > b || a === void 0) return 1;\n      if (a < b || b === void 0) return -1;\n    }\n    return left.index - right.index;\n  }), 'value');\n};\n\n// An internal function used for aggregate \"group by\" operations.\nvar group = function(behavior) {\n  return function(obj, value, context) {\n    var result = {};\n    var iterator = value == null ? _.identity : lookupIterator(value);\n    each(obj, function(value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  };\n};\n\n// Groups the object's values by a criterion. Pass either a string attribute\n// to group by, or a function that returns the criterion.\n_.groupBy = group(function(result, key, value) {\n  (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n});\n\n// Indexes the object's values by a criterion, similar to `groupBy`, but for\n// when you know that your index values will be unique.\n_.indexBy = group(function(result, key, value) {\n  result[key] = value;\n});\n\n// Counts instances of an object that group by a certain criterion. Pass\n// either a string attribute to count by, or a function that returns the\n// criterion.\n_.countBy = group(function(result, key) {\n  _.has(result, key) ? result[key]++ : result[key] = 1;\n});\n\n// Use a comparator function to figure out the smallest index at which\n// an object should be inserted so as to maintain order. Uses binary search.\n_.sortedIndex = function(array, obj, iterator, context) {\n  iterator = iterator == null ? _.identity : lookupIterator(iterator);\n  var value = iterator.call(context, obj);\n  var low = 0, high = array.length;\n  while (low < high) {\n    var mid = (low + high) >>> 1;\n    iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n  }\n  return low;\n};\n\n// Safely create a real, live array from anything iterable.\n_.toArray = function(obj) {\n  if (!obj) return [];\n  if (_.isArray(obj)) return slice.call(obj);\n  if (looksLikeArray(obj)) return _.map(obj, _.identity);\n  return _.values(obj);\n};\n\n// Return the number of elements in an object.\n_.size = function(obj) {\n  if (obj == null) return 0;\n  return (looksLikeArray(obj)) ? obj.length : _.keys(obj).length;\n};\n\n// Array Functions\n// ---------------\n\n// Get the first element of an array. Passing **n** will return the first N\n// values in the array. Aliased as `head` and `take`. The **guard** check\n// allows it to work with `_.map`.\n_.first = _.head = _.take = function(array, n, guard) {\n  if (array == null) return void 0;\n  return (n == null) || guard ? array[0] : slice.call(array, 0, n);\n};\n\n// Returns everything but the last entry of the array. Especially useful on\n// the arguments object. Passing **n** will return all the values in\n// the array, excluding the last N. The **guard** check allows it to work with\n// `_.map`.\n_.initial = function(array, n, guard) {\n  return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n};\n\n// Get the last element of an array. Passing **n** will return the last N\n// values in the array. The **guard** check allows it to work with `_.map`.\n_.last = function(array, n, guard) {\n  if (array == null) return void 0;\n  if ((n == null) || guard) {\n    return array[array.length - 1];\n  } else {\n    return slice.call(array, Math.max(array.length - n, 0));\n  }\n};\n\n// Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n// Especially useful on the arguments object. Passing an **n** will return\n// the rest N values in the array. The **guard**\n// check allows it to work with `_.map`.\n_.rest = _.tail = _.drop = function(array, n, guard) {\n  return slice.call(array, (n == null) || guard ? 1 : n);\n};\n\n// Trim out all falsy values from an array.\n_.compact = function(array) {\n  return _.filter(array, _.identity);\n};\n\n// Internal implementation of a recursive `flatten` function.\nvar flatten = function(input, shallow, output) {\n  if (shallow && _.every(input, _.isArray)) {\n    return concat.apply(output, input);\n  }\n  each(input, function(value) {\n    if (_.isArray(value) || _.isArguments(value)) {\n      shallow ? push.apply(output, value) : flatten(value, shallow, output);\n    } else {\n      output.push(value);\n    }\n  });\n  return output;\n};\n\n// Flatten out an array, either recursively (by default), or just one level.\n_.flatten = function(array, shallow) {\n  return flatten(array, shallow, []);\n};\n\n// Return a version of the array that does not contain the specified value(s).\n_.without = function(array) {\n  return _.difference(array, slice.call(arguments, 1));\n};\n\n// Produce a duplicate-free version of the array. If the array has already\n// been sorted, you have the option of using a faster algorithm.\n// Aliased as `unique`.\n_.uniq = _.unique = function(array, isSorted, iterator, context) {\n  if (_.isFunction(isSorted)) {\n    context = iterator;\n    iterator = isSorted;\n    isSorted = false;\n  }\n  var initial = iterator ? _.map(array, iterator, context) : array;\n  var results = [];\n  var seen = [];\n  each(initial, function(value, index) {\n    if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n      seen.push(value);\n      results.push(array[index]);\n    }\n  });\n  return results;\n};\n\n// Produce an array that contains the union: each distinct element from all of\n// the passed-in arrays.\n_.union = function() {\n  return _.uniq(_.flatten(arguments, true));\n};\n\n// Produce an array that contains every item shared between all the\n// passed-in arrays.\n_.intersection = function(array) {\n  var rest = slice.call(arguments, 1);\n  return _.filter(_.uniq(array), function(item) {\n    return _.every(rest, function(other) {\n      return _.indexOf(other, item) >= 0;\n    });\n  });\n};\n\n// Take the difference between one array and a number of other arrays.\n// Only the elements present in just the first array will remain.\n_.difference = function(array) {\n  var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n  return _.filter(array, function(value){ return !_.contains(rest, value); });\n};\n\n// Zip together multiple lists into a single array -- elements that share\n// an index go together.\n_.zip = function() {\n  var length = _.max(_.pluck(arguments, \"length\").concat(0));\n  var results = new Array(length);\n  for (var i = 0; i < length; i++) {\n    results[i] = _.pluck(arguments, '' + i);\n  }\n  return results;\n};\n\n// Converts lists into objects. Pass either a single array of `[key, value]`\n// pairs, or two parallel arrays of the same length -- one of keys, and one of\n// the corresponding values.\n_.object = function(list, values) {\n  if (list == null) return {};\n  var result = {};\n  for (var i = 0, length = list.length; i < length; i++) {\n    if (values) {\n      result[list[i]] = values[i];\n    } else {\n      result[list[i][0]] = list[i][1];\n    }\n  }\n  return result;\n};\n\n// If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n// we need this function. Return the position of the first occurrence of an\n// item in an array, or -1 if the item is not included in the array.\n// Delegates to **ECMAScript 5**'s native `indexOf` if available.\n// If the array is large and already in sort order, pass `true`\n// for **isSorted** to use binary search.\n_.indexOf = function(array, item, isSorted) {\n  if (array == null) return -1;\n  var i = 0, length = array.length;\n  if (isSorted) {\n    if (typeof isSorted == 'number') {\n      i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);\n    } else {\n      i = _.sortedIndex(array, item);\n      return array[i] === item ? i : -1;\n    }\n  }\n  if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n  for (; i < length; i++) if (array[i] === item) return i;\n  return -1;\n};\n\n// Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n_.lastIndexOf = function(array, item, from) {\n  if (array == null) return -1;\n  var hasIndex = from != null;\n  if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n    return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n  }\n  var i = (hasIndex ? from : array.length);\n  while (i--) if (array[i] === item) return i;\n  return -1;\n};\n\n// Generate an integer Array containing an arithmetic progression. A port of\n// the native Python `range()` function. See\n// [the Python documentation](http://docs.python.org/library/functions.html#range).\n_.range = function(start, stop, step) {\n  if (arguments.length <= 1) {\n    stop = start || 0;\n    start = 0;\n  }\n  step = arguments[2] || 1;\n\n  var length = Math.max(Math.ceil((stop - start) / step), 0);\n  var idx = 0;\n  var range = new Array(length);\n\n  while(idx < length) {\n    range[idx++] = start;\n    start += step;\n  }\n\n  return range;\n};\n\n// Function (ahem) Functions\n// ------------------\n\n// Reusable constructor function for prototype setting.\nvar ctor = function(){};\n\n// Create a function bound to a given object (assigning `this`, and arguments,\n// optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n// available.\n_.bind = function(func, context) {\n  var args, bound;\n  if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n  if (!_.isFunction(func)) throw new TypeError;\n  args = slice.call(arguments, 2);\n  return bound = function() {\n    if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n    ctor.prototype = func.prototype;\n    var self = new ctor;\n    ctor.prototype = null;\n    var result = func.apply(self, args.concat(slice.call(arguments)));\n    if (Object(result) === result) return result;\n    return self;\n  };\n};\n\n// Partially apply a function by creating a version that has had some of its\n// arguments pre-filled, without changing its dynamic `this` context.\n_.partial = function(func) {\n  var args = slice.call(arguments, 1);\n  return function() {\n    return func.apply(this, args.concat(slice.call(arguments)));\n  };\n};\n\n// Bind all of an object's methods to that object. Useful for ensuring that\n// all callbacks defined on an object belong to it.\n_.bindAll = function(obj) {\n  var funcs = slice.call(arguments, 1);\n  if (funcs.length === 0) throw new Error(\"bindAll must be passed function names\");\n  each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n  return obj;\n};\n\n// Memoize an expensive function by storing its results.\n_.memoize = function(func, hasher) {\n  var memo = {};\n  hasher || (hasher = _.identity);\n  return function() {\n    var key = hasher.apply(this, arguments);\n    return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n  };\n};\n\n// Delays a function for the given number of milliseconds, and then calls\n// it with the arguments supplied.\n_.delay = function(func, wait) {\n  var args = slice.call(arguments, 2);\n  return setTimeout(function(){ return func.apply(null, args); }, wait);\n};\n\n// Defers a function, scheduling it to run after the current call stack has\n// cleared.\n_.defer = function(func) {\n  return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n};\n\n// Returns a function, that, when invoked, will only be triggered at most once\n// during a given window of time. Normally, the throttled function will run\n// as much as it can, without ever going more than once per `wait` duration;\n// but if you'd like to disable the execution on the leading edge, pass\n// `{leading: false}`. To disable execution on the trailing edge, ditto.\n_.throttle = function(func, wait, options) {\n  var context, args, result;\n  var timeout = null;\n  var previous = 0;\n  options || (options = {});\n  var later = function() {\n    previous = options.leading === false ? 0 : new Date;\n    timeout = null;\n    result = func.apply(context, args);\n  };\n  return function() {\n    var now = new Date;\n    if (!previous && options.leading === false) previous = now;\n    var remaining = wait - (now - previous);\n    context = this;\n    args = arguments;\n    if (remaining <= 0) {\n      clearTimeout(timeout);\n      timeout = null;\n      previous = now;\n      result = func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n};\n\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n_.debounce = function(func, wait, immediate) {\n  var timeout, args, context, timestamp, result;\n  return function() {\n    context = this;\n    args = arguments;\n    timestamp = new Date();\n    var later = function() {\n      var last = (new Date()) - timestamp;\n      if (last < wait) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      }\n    };\n    var callNow = immediate && !timeout;\n    if (!timeout) {\n      timeout = setTimeout(later, wait);\n    }\n    if (callNow) result = func.apply(context, args);\n    return result;\n  };\n};\n\n// Returns a function that will be executed at most one time, no matter how\n// often you call it. Useful for lazy initialization.\n_.once = function(func) {\n  var ran = false, memo;\n  return function() {\n    if (ran) return memo;\n    ran = true;\n    memo = func.apply(this, arguments);\n    func = null;\n    return memo;\n  };\n};\n\n// Returns the first function passed as an argument to the second,\n// allowing you to adjust arguments, run code before and after, and\n// conditionally execute the original function.\n_.wrap = function(func, wrapper) {\n  return function() {\n    var args = [func];\n    push.apply(args, arguments);\n    return wrapper.apply(this, args);\n  };\n};\n\n// Returns a function that is the composition of a list of functions, each\n// consuming the return value of the function that follows.\n_.compose = function() {\n  var funcs = arguments;\n  return function() {\n    var args = arguments;\n    for (var i = funcs.length - 1; i >= 0; i--) {\n      args = [funcs[i].apply(this, args)];\n    }\n    return args[0];\n  };\n};\n\n// Returns a function that will only be executed after being called N times.\n_.after = function(times, func) {\n  return function() {\n    if (--times < 1) {\n      return func.apply(this, arguments);\n    }\n  };\n};\n\n// Object Functions\n// ----------------\n\n// Retrieve the names of an object's properties.\n// Delegates to **ECMAScript 5**'s native `Object.keys`\n_.keys = nativeKeys || function(obj) {\n  if (obj !== Object(obj)) throw new TypeError('Invalid object');\n  var keys = [];\n  for (var key in obj) if (_.has(obj, key)) keys.push(key);\n  return keys;\n};\n\n// Retrieve the values of an object's properties.\n_.values = function(obj) {\n  var keys = _.keys(obj);\n  var length = keys.length;\n  var values = new Array(length);\n  for (var i = 0; i < length; i++) {\n    values[i] = obj[keys[i]];\n  }\n  return values;\n};\n\n// Convert an object into a list of `[key, value]` pairs.\n_.pairs = function(obj) {\n  var keys = _.keys(obj);\n  var length = keys.length;\n  var pairs = new Array(length);\n  for (var i = 0; i < length; i++) {\n    pairs[i] = [keys[i], obj[keys[i]]];\n  }\n  return pairs;\n};\n\n// Invert the keys and values of an object. The values must be serializable.\n_.invert = function(obj) {\n  var result = {};\n  var keys = _.keys(obj);\n  for (var i = 0, length = keys.length; i < length; i++) {\n    result[obj[keys[i]]] = keys[i];\n  }\n  return result;\n};\n\n// Return a sorted list of the function names available on the object.\n// Aliased as `methods`\n_.functions = _.methods = function(obj) {\n  var names = [];\n  for (var key in obj) {\n    if (_.isFunction(obj[key])) names.push(key);\n  }\n  return names.sort();\n};\n\n// Extend a given object with all the properties in passed-in object(s).\n_.extend = function(obj) {\n  each(slice.call(arguments, 1), function(source) {\n    if (source) {\n      for (var prop in source) {\n        obj[prop] = source[prop];\n      }\n    }\n  });\n  return obj;\n};\n\n// Return a copy of the object only containing the whitelisted properties.\n_.pick = function(obj) {\n  var copy = {};\n  var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n  each(keys, function(key) {\n    if (key in obj) copy[key] = obj[key];\n  });\n  return copy;\n};\n\n // Return a copy of the object without the blacklisted properties.\n_.omit = function(obj) {\n  var copy = {};\n  var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n  for (var key in obj) {\n    if (!_.contains(keys, key)) copy[key] = obj[key];\n  }\n  return copy;\n};\n\n// Fill in a given object with default properties.\n_.defaults = function(obj) {\n  each(slice.call(arguments, 1), function(source) {\n    if (source) {\n      for (var prop in source) {\n        if (obj[prop] === void 0) obj[prop] = source[prop];\n      }\n    }\n  });\n  return obj;\n};\n\n// Create a (shallow-cloned) duplicate of an object.\n_.clone = function(obj) {\n  if (!_.isObject(obj)) return obj;\n  return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n};\n\n// Invokes interceptor with the obj, and then returns obj.\n// The primary purpose of this method is to \"tap into\" a method chain, in\n// order to perform operations on intermediate results within the chain.\n_.tap = function(obj, interceptor) {\n  interceptor(obj);\n  return obj;\n};\n\n// Internal recursive comparison function for `isEqual`.\nvar eq = function(a, b, aStack, bStack) {\n  // Identical objects are equal. `0 === -0`, but they aren't identical.\n  // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n  if (a === b) return a !== 0 || 1 / a == 1 / b;\n  // A strict comparison is necessary because `null == undefined`.\n  if (a == null || b == null) return a === b;\n  // Unwrap any wrapped objects.\n  if (a instanceof _) a = a._wrapped;\n  if (b instanceof _) b = b._wrapped;\n  // Compare `[[Class]]` names.\n  var className = toString.call(a);\n  if (className != toString.call(b)) return false;\n  switch (className) {\n    // Strings, numbers, dates, and booleans are compared by value.\n    case '[object String]':\n      // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n      // equivalent to `new String(\"5\")`.\n      return a == String(b);\n    case '[object Number]':\n      // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n      // other numeric values.\n      return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n    case '[object Date]':\n    case '[object Boolean]':\n      // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n      // millisecond representations. Note that invalid dates with millisecond representations\n      // of `NaN` are not equivalent.\n      return +a == +b;\n    // RegExps are compared by their source patterns and flags.\n    case '[object RegExp]':\n      return a.source == b.source &&\n             a.global == b.global &&\n             a.multiline == b.multiline &&\n             a.ignoreCase == b.ignoreCase;\n  }\n  if (typeof a != 'object' || typeof b != 'object') return false;\n  // Assume equality for cyclic structures. The algorithm for detecting cyclic\n  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n  var length = aStack.length;\n  while (length--) {\n    // Linear search. Performance is inversely proportional to the number of\n    // unique nested structures.\n    if (aStack[length] == a) return bStack[length] == b;\n  }\n  // Objects with different constructors are not equivalent, but `Object`s\n  // from different frames are.\n  var aCtor = a.constructor, bCtor = b.constructor;\n  if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                           _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n    return false;\n  }\n  // Add the first object to the stack of traversed objects.\n  aStack.push(a);\n  bStack.push(b);\n  var size = 0, result = true;\n  // Recursively compare objects and arrays.\n  if (className == '[object Array]') {\n    // Compare array lengths to determine if a deep comparison is necessary.\n    size = a.length;\n    result = size == b.length;\n    if (result) {\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (size--) {\n        if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n      }\n    }\n  } else {\n    // Deep compare objects.\n    for (var key in a) {\n      if (_.has(a, key)) {\n        // Count the expected number of properties.\n        size++;\n        // Deep compare each member.\n        if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n      }\n    }\n    // Ensure that both objects contain the same number of properties.\n    if (result) {\n      for (key in b) {\n        if (_.has(b, key) && !(size--)) break;\n      }\n      result = !size;\n    }\n  }\n  // Remove the first object from the stack of traversed objects.\n  aStack.pop();\n  bStack.pop();\n  return result;\n};\n\n// Perform a deep comparison to check if two objects are equal.\n_.isEqual = function(a, b) {\n  return eq(a, b, [], []);\n};\n\n// Is a given array, string, or object empty?\n// An \"empty\" object has no enumerable own-properties.\n_.isEmpty = function(obj) {\n  if (obj == null) return true;\n  if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n  for (var key in obj) if (_.has(obj, key)) return false;\n  return true;\n};\n\n// Is a given value a DOM element?\n_.isElement = function(obj) {\n  return !!(obj && obj.nodeType === 1);\n};\n\n// Is a given value an array?\n// Delegates to ECMA5's native Array.isArray\n_.isArray = nativeIsArray || function(obj) {\n  return toString.call(obj) == '[object Array]';\n};\n\n// Is a given variable an object?\n_.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\n// Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\neach(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n  _['is' + name] = function(obj) {\n    return toString.call(obj) == '[object ' + name + ']';\n  };\n});\n\n// Define a fallback version of the method in browsers (ahem, IE), where\n// there isn't any inspectable \"Arguments\" type.\nif (!_.isArguments(arguments)) {\n  _.isArguments = function(obj) {\n    return !!(obj && _.has(obj, 'callee'));\n  };\n}\n\n// Optimize `isFunction` if appropriate.\nif (typeof (/./) !== 'function') {\n  _.isFunction = function(obj) {\n    return typeof obj === 'function';\n  };\n}\n\n// Is a given object a finite number?\n_.isFinite = function(obj) {\n  return isFinite(obj) && !isNaN(parseFloat(obj));\n};\n\n// Is the given value `NaN`? (NaN is the only number which does not equal itself).\n_.isNaN = function(obj) {\n  return _.isNumber(obj) && obj != +obj;\n};\n\n// Is a given value a boolean?\n_.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\n// Is a given value equal to null?\n_.isNull = function(obj) {\n  return obj === null;\n};\n\n// Is a given variable undefined?\n_.isUndefined = function(obj) {\n  return obj === void 0;\n};\n\n// Shortcut function for checking if an object has a given property directly\n// on itself (in other words, not on a prototype).\n_.has = function(obj, key) {\n  return hasOwnProperty.call(obj, key);\n};\n\n// Utility Functions\n// -----------------\n\n// Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n// previous owner. Returns a reference to the Underscore object.\n_.noConflict = function() {\n  root._ = previousUnderscore;\n  return this;\n};\n\n// Keep the identity function around for default iterators.\n_.identity = function(value) {\n  return value;\n};\n\n// Run a function **n** times.\n_.times = function(n, iterator, context) {\n  var accum = Array(Math.max(0, n));\n  for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n  return accum;\n};\n\n// Return a random integer between min and max (inclusive).\n_.random = function(min, max) {\n  if (max == null) {\n    max = min;\n    min = 0;\n  }\n  return min + Math.floor(Math.random() * (max - min + 1));\n};\n\n// List of HTML entities for escaping.\nvar entityMap = {\n  escape: {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;'\n  }\n};\nentityMap.unescape = _.invert(entityMap.escape);\n\n// Regexes containing the keys and values listed immediately above.\nvar entityRegexes = {\n  escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n  unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n};\n\n// Functions for escaping and unescaping strings to/from HTML interpolation.\n_.each(['escape', 'unescape'], function(method) {\n  _[method] = function(string) {\n    if (string == null) return '';\n    return ('' + string).replace(entityRegexes[method], function(match) {\n      return entityMap[method][match];\n    });\n  };\n});\n\n// If the value of the named `property` is a function then invoke it with the\n// `object` as context; otherwise, return it.\n_.result = function(object, property) {\n  if (object == null) return void 0;\n  var value = object[property];\n  return _.isFunction(value) ? value.call(object) : value;\n};\n\n// Add your own custom functions to the Underscore object.\n_.mixin = function(obj) {\n  each(_.functions(obj), function(name) {\n    var func = _[name] = obj[name];\n    _.prototype[name] = function() {\n      var args = [this._wrapped];\n      push.apply(args, arguments);\n      return result.call(this, func.apply(_, args));\n    };\n  });\n};\n\n// Generate a unique integer id (unique within the entire client session).\n// Useful for temporary DOM ids.\nvar idCounter = 0;\n_.uniqueId = function(prefix) {\n  var id = ++idCounter + '';\n  return prefix ? prefix + id : id;\n};\n\n// By default, Underscore uses ERB-style template delimiters, change the\n// following template settings to use alternative delimiters.\n_.templateSettings = {\n  evaluate    : /<%([\\s\\S]+?)%>/g,\n  interpolate : /<%=([\\s\\S]+?)%>/g,\n  escape      : /<%-([\\s\\S]+?)%>/g\n};\n\n// When customizing `templateSettings`, if you don't want to define an\n// interpolation, evaluation or escaping regex, we need one that is\n// guaranteed not to match.\nvar noMatch = /(.)^/;\n\n// Certain characters need to be escaped so that they can be put into a\n// string literal.\nvar escapes = {\n  \"'\":      \"'\",\n  '\\\\':     '\\\\',\n  '\\r':     'r',\n  '\\n':     'n',\n  '\\t':     't',\n  '\\u2028': 'u2028',\n  '\\u2029': 'u2029'\n};\n\nvar escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n// JavaScript micro-templating, similar to John Resig's implementation.\n// Underscore templating handles arbitrary delimiters, preserves whitespace,\n// and correctly escapes quotes within interpolated code.\n_.template = function(text, data, settings) {\n  var render;\n  settings = _.defaults({}, settings, _.templateSettings);\n\n  // Combine delimiters into one regular expression via alternation.\n  var matcher = new RegExp([\n    (settings.escape || noMatch).source,\n    (settings.interpolate || noMatch).source,\n    (settings.evaluate || noMatch).source\n  ].join('|') + '|$', 'g');\n\n  // Compile the template source, escaping string literals appropriately.\n  var index = 0;\n  var source = \"__p+='\";\n  text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n    source += text.slice(index, offset)\n      .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n    if (escape) {\n      source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n    }\n    if (interpolate) {\n      source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n    }\n    if (evaluate) {\n      source += \"';\\n\" + evaluate + \"\\n__p+='\";\n    }\n    index = offset + match.length;\n    return match;\n  });\n  source += \"';\\n\";\n\n  // If a variable is not specified, place data values in local scope.\n  if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n  source = \"var __t,__p='',__j=Array.prototype.join,\" +\n    \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n    source + \"return __p;\\n\";\n\n  try {\n    render = new Function(settings.variable || 'obj', '_', source);\n  } catch (e) {\n    e.source = source;\n    throw e;\n  }\n\n  if (data) return render(data, _);\n  var template = function(data) {\n    return render.call(this, data, _);\n  };\n\n  // Provide the compiled function source as a convenience for precompilation.\n  template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n  return template;\n};\n\n// Add a \"chain\" function, which will delegate to the wrapper.\n_.chain = function(obj) {\n  return _(obj).chain();\n};\n\n// OOP\n// ---------------\n// If Underscore is called as a function, it returns a wrapped object that\n// can be used OO-style. This wrapper holds altered versions of all the\n// underscore functions. Wrapped objects may be chained.\n\n// Helper function to continue chaining intermediate results.\nvar result = function(obj) {\n  return this._chain ? _(obj).chain() : obj;\n};\n\n// Add all of the Underscore functions to the wrapper object.\n_.mixin(_);\n\n// Add all mutator Array functions to the wrapper.\neach(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n  var method = ArrayProto[name];\n  _.prototype[name] = function() {\n    var obj = this._wrapped;\n    method.apply(obj, arguments);\n    if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n    return result.call(this, obj);\n  };\n});\n\n// Add all accessor Array functions to the wrapper.\neach(['concat', 'join', 'slice'], function(name) {\n  var method = ArrayProto[name];\n  _.prototype[name] = function() {\n    return result.call(this, method.apply(this._wrapped, arguments));\n  };\n});\n\n_.extend(_.prototype, {\n\n  // Start chaining a wrapped Underscore object.\n  chain: function() {\n    this._chain = true;\n    return this;\n  },\n\n  // Extracts the result from a wrapped and chained object.\n  value: function() {\n    return this._wrapped;\n  }\n\n});\n\n\n","/home/travis/build/npmtest/node-npmtest-ddp/node_modules/ddp-ejson/objectid.js":"// Copyright (C) 2014 Vaughn Iverson\n//\n// Adapted from:\n// https://github.com/meteor/meteor/blob/5a5204e3a468b7b498baefb259c88a63b23699cf/packages/minimongo/objectid.js\n// https://github.com/meteor/meteor/blob/cc667a487f0f32cf592df14aae80f45d0b3b6d84/packages/random/random.js\n//\n// Copyright (C) 2011-2014 Meteor Development Group\n//\n// All contributions licensed under the MIT license: see LICENSE file in this directory\n\nnodeCrypto = require('crypto');\n\nrandomHexString = function (digits) {\n  var self = this;\n  var numBytes = Math.ceil(digits / 2);\n  var bytes;\n  // Try to get cryptographically strong randomness. Fall back to\n  // non-cryptographically strong if not available.\n  try {\n    bytes = nodeCrypto.randomBytes(numBytes);\n  } catch (e) {\n    // XXX should re-throw any error except insufficient entropy\n    bytes = nodeCrypto.pseudoRandomBytes(numBytes);\n  }\n  var result = bytes.toString(\"hex\");\n  // If the number of digits is odd, we'll have generated an extra 4 bits\n  // of randomness, so we need to trim the last digit.\n  return result.substring(0, digits);\n};\n\nlooksLikeObjectID = function (str) {\n  return str.length === 24 && str.match(/^[0-9a-f]*$/);\n};\n\nObjectID = function (hexString) {\n  // Make new optional\n  if (!(this instanceof ObjectID))\n    return new ObjectID(hexString);\n\n  //random-based impl of Mongo ObjectID\n  var self = this;\n  if (hexString && (typeof hexString === 'string')) {\n    hexString = hexString.toLowerCase();\n    if (!looksLikeObjectID(hexString)) {\n      throw new Error(\"Invalid hexadecimal string for creating an ObjectID\");\n    }\n    // meant to work with _.isEqual(), which relies on structural equality\n    self._str = hexString;\n  } else {\n    self._str = randomHexString(24);\n  }\n};\n\nObjectID.prototype.toString = function () {\n  var self = this;\n  return \"ObjectID(\\\"\" + self._str + \"\\\")\";\n};\n\nObjectID.prototype.equals = function (other) {\n  var self = this;\n  return other instanceof ObjectID &&\n    self.valueOf() === other.valueOf();\n};\n\nObjectID.prototype.clone = function () {\n  var self = this;\n  return new ObjectID(self._str);\n};\n\nObjectID.prototype.typeName = function() {\n  return \"oid\";\n};\n\n// Only use this if mongodb made this ID, otherwise this will be nonsense\nObjectID.prototype.getTimestamp = function() {\n  var self = this;\n  return parseInt(self._str.substr(0, 8), 16);\n};\n\nObjectID.prototype.valueOf =\n    ObjectID.prototype.toJSONValue =\n    ObjectID.prototype.toHexString =\n    function () { return this._str; };\n\n// Export ObjectID\nmodule.exports = ObjectID\n"}